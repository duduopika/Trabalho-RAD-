# -*- coding: utf-8 -*-
"""Notas Alunos Desenvolvimento Rápido em Python

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B0NFlddYyNvlngW_NP69KaUfNgeTqvUe
"""

#validação e exportação dos dados

import csv
import json
import os
import random
import string

#nomes aleatórios e dos integrantes dos grupos
nomes_base = ["Andressa da Silva", "Bruno", "Carlos", "Daniela", "Eduardo Cordeiro", "Fernanda", "Augusto", "José Pedro da Galera", "Gabriel", "Geovana", "Cazuza", "Ticolé da Galera", "Tienam", "Luan", "Rômulo"]
integrantes_grupo = ["Eduardo Cordeiro", "Lucas Gabriel", "Andressa da Silva", "Ricardo dos Santos", "Guilherme Lourenço", "Renan Cardoso"]

nomes_completos = random.sample(nomes_base, 15) + integrantes_grupo
random.shuffle(nomes_completos)

#função de validação
def validar_nome(nome):
    if any(char.isdigit() for char in nome):
        raise ValueError("O nome não pode conter números.")
    return nome

def validar_nota(nota):
    nota = float(nota)
    if nota < 0 or nota > 10:
        raise ValueError("A nota deve estar entre 0 e 10.")
    return nota

def validar_matricula(matricula):
    if not matricula.isdigit():
        raise ValueError("A matrícula deve conter apenas números.")
    return matricula

#gerando os registros
def gerar_registros(min_registros=15):
    registros = []
    for nome in nomes_completos:
        try:
            validar_nome(nome)
            matricula = ''.join(random.choices(string.digits, k=12))
            validar_matricula(matricula)
            nota = round(random.uniform(0, 10))
            validar_nota(nota)
            registros.append({
                "nome": nome,
                "matricula": matricula,
                "nota": nota
            })
        except ValueError as e:
            print(f"Erro ao gerar registro para {nome}: {e}")
    return registros

#exportando csv
def exportar_csv(registros, caminho="registros.csv"):
    try:
        with open(caminho, mode='w', newline='', encoding='utf-8') as file:
            writer = csv.DictWriter(file, fieldnames=["nome", "matricula", "nota"])
            writer.writeheader()
            writer.writerows(registros)
        print(f"CSV exportado para {caminho}")
    except PermissionError:
        print("Erro: Sem permissão para escrever no arquivo CSV.")

#exportando JSON
def exportar_json(registros, caminho="registros.json"):
    try:
        with open(caminho, mode='w', encoding='utf-8') as file:
            json.dump(registros, file, indent=4, ensure_ascii=False)
        print(f"JSON exportado para {caminho}")
    except PermissionError:
        print("Erro: Sem permissão para escrever no arquivo JSON.")

#importando csv
def importar_csv(caminho="registros.csv"):
    if not os.path.exists(caminho):
        print("Erro: Arquivo CSV inexistente.")
        return []
    with open(caminho, mode='r', encoding='utf-8') as file:
        reader = csv.DictReader(file)
        return list(reader)

#importando JSON
def importar_json(caminho="registros.json"):
    if not os.path.exists(caminho):
        print("Erro: Arquivo JSON inexistente.")
        return []
    with open(caminho, mode='r', encoding='utf-8') as file:
        return json.load(file)

#salvar como txt
def exportar_txt(registros, caminho="registros.txt"):
    try:
        with open(caminho, 'w', encoding='utf-8') as f:
            for r in registros:
                f.write(f"{r['nome']} | Matrícula: {r['matricula']} | Nota: {r['nota']}\n")
        print(f"TXT exportado para {caminho}")
    except PermissionError:
        print("Erro: Arquivo está protegido contra escrita.")

#executando o principal
registros = gerar_registros()

#exportando para todos os formatos
exportar_csv(registros)
exportar_json(registros)
exportar_txt(registros)

#importação
dados_csv = importar_csv()
dados_json = importar_json()

#visualização
print("\nDados Importados do CSV:")
for item in dados_csv[:3]:
    print(item)

print("\nDados Importados do JSON:")
for item in dados_json[:3]:
    print(item)

import sqlite3
import csv
import json
import random
import os

#nome do banco de dados
DB_NAME = "notas.db"
TABLE_NAME = "notas"

#função de conexão com o banco de dados SQLite
def conectar():
    return sqlite3.connect(DB_NAME)

#função para criar a tabela de notas no banco de dados
def criar_tabela():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute(f"""
            CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT NOT NULL,
                matricula TEXT NOT NULL UNIQUE,
                nota REAL NOT NULL
            )
        """)
        conn.commit()
        print("Tabela criada com sucesso!")
    except Exception as e:
        print(f"Erro ao criar tabela: {e}")
    finally:
        conn.close()

#função para inserir um novo registro
def inserir_nota(nome, matricula, nota):
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute(f"""
            INSERT INTO {TABLE_NAME} (nome, matricula, nota)
            VALUES (?, ?, ?)
        """, (nome, matricula, nota))
        conn.commit()
        print(f"Registro inserido: {nome}, {matricula}, {nota}")
    except sqlite3.IntegrityError as e:
        print(f"Erro de integridade: {e}")
    except Exception as e:
        print(f"Erro ao inserir nota: {e}")
    finally:
        conn.close()

#função para listar todos os registros
def listar_notas():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute(f"SELECT * FROM {TABLE_NAME}")
        rows = cursor.fetchall()
        return rows
    except Exception as e:
        print(f"Erro ao listar notas: {e}")
        return []
    finally:
        conn.close()

#função para atualizar a nota de um aluno
def atualizar_nota(id, nova_nota):
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute(f"""
            UPDATE {TABLE_NAME}
            SET nota = ?
            WHERE id = ?
        """, (nova_nota, id))
        conn.commit()
        if cursor.rowcount == 0:
            print("ID não encontrado.")
        else:
            print(f"Nota do aluno com ID {id} atualizada para {nova_nota}.")
    except Exception as e:
        print(f"Erro ao atualizar nota: {e}")
    finally:
        conn.close()

#função para deletar  um registro
def deletar_nota(id):
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute(f"DELETE FROM {TABLE_NAME} WHERE id = ?", (id,))
        conn.commit()
        if cursor.rowcount == 0:
            print("ID não encontrado.")
        else:
            print(f"Registro com ID {id} deletado.")
    except Exception as e:
        print(f"Erro ao deletar nota: {e}")
    finally:
        conn.close()

#função para gerar os registros iniciais ≥15
def gerar_registros_iniciais():
    nomes = ["Andressa da Silva", "Bruno", "Carlos", "Daniela", "Eduardo Cordeiro", "Fernanda", "Augusto", "José Pedro da Galera", "Gabriel", "Geovana", "Cazuza", "Ticolé da Galera", "Tienam", "Luan", "Rômulo"]
    registros = []
    for nome in nomes:
        matricula = str(random.randint(100000000000, 999999999999))
        nota = round(random.uniform(0, 10), 1)
        registros.append((nome, matricula, nota))

    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.executemany(f"""
            INSERT INTO {TABLE_NAME} (nome, matricula, nota)
            VALUES (?, ?, ?)
        """, registros)
        conn.commit()
        print("15 registros iniciais inseridos com sucesso!")
    except Exception as e:
        print(f"Erro ao gerar registros iniciais: {e}")
    finally:
        conn.close()

#função para exportar dados para csv
def exportar_csv(filename="notas.csv"):
    try:
        registros = listar_notas()
        with open(filename, mode="w", newline="", encoding="utf-8") as file:
            writer = csv.writer(file)
            writer.writerow(["id", "nome", "matricula", "nota"])
            writer.writerows(registros)
        print(f"Exportado para {filename}")
    except Exception as e:
        print(f"Erro ao exportar para CSV: {e}")

#função para exportar os dados para json
def exportar_json(filename="notas.json"):
    try:
        registros = listar_notas()
        data = [{"id": r[0], "nome": r[1], "matricula": r[2], "nota": r[3]} for r in registros]
        with open(filename, "w", encoding="utf-8") as file:
            json.dump(data, file, indent=4, ensure_ascii=False)
        print(f"Exportado para {filename}")
    except Exception as e:
        print(f"Erro ao exportar para JSON: {e}")

#função para importar os dados de csv
def importar_csv(filename="notas.csv"):
    try:
        with open(filename, mode="r", encoding="utf-8") as file:
            reader = csv.DictReader(file)
            for row in reader:
                inserir_nota(row["nome"], row["matricula"], float(row["nota"]))
        print(f"Importado de {filename}")
    except Exception as e:
        print(f"Erro ao importar de CSV: {e}")

#função para importar dados de JSON
def importar_json(filename="notas.json"):
    try:
        with open(filename, "r", encoding="utf-8") as file:
            data = json.load(file)
            for item in data:
                inserir_nota(item["nome"], item["matricula"], item["nota"])
        print(f"Importado de {filename}")
    except Exception as e:
        print(f"Erro ao importar de JSON: {e}")

#menu totalmente interativo
def menu():
    while True:
        print("\n--- MENU ---")
        print("1. Listar as notas")
        print("2. Inserir uma nova nota")
        print("3. Atualizar a nota")
        print("4. Deletar a nota")
        print("5. Exportar para CSV")
        print("6. Importar de CSV")
        print("7. Exportar para JSON")
        print("8. Importar de JSON")
        print("9. Sair")

        try:
            opcao = int(input("Escolha uma opção: "))
            if opcao == 1:
                notas = listar_notas()
                for nota in notas:
                    print(nota)
            elif opcao == 2:
                nome = input("Nome do aluno: ")
                matricula = input("Matrícula: ")
                nota = float(input("Nota: "))
                inserir_nota(nome, matricula, nota)
            elif opcao == 3:
                id = int(input("ID da nota: "))
                nova_nota = float(input("Nova nota: "))
                atualizar_nota(id, nova_nota)
            elif opcao == 4:
                id = int(input("ID da nota a deletar: "))
                deletar_nota(id)
            elif opcao == 5:
                exportar_csv()
            elif opcao == 6:
                importar_csv()
            elif opcao == 7:
                exportar_json()
            elif opcao == 8:
                importar_json()
            elif opcao == 9:
                print("Encerrando...")
                break
            else:
                print("Opção inválida.")
        except Exception as e:
            print(f"Erro no menu: {e}")

if __name__ == "__main__":
    criar_tabela()
    gerar_registros_iniciais()  #gera os registros iniciais SE a tabela estiver vazia
    menu()

import sqlite3
import csv
import json
import random
import os

DB_NAME = "notas.db"
TABLE_NAME = "notas"

def conectar():
    return sqlite3.connect(DB_NAME)

# Criar tabelas
def criar_tabela():
    try:
        conn = conectar()
        cursor = conn.cursor()

        # TABELA DE ALUNOS
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS alunos (
                matricula TEXT PRIMARY KEY,
                nome TEXT NOT NULL
            )
        """)

        # TABELA DE NOTAS (SEM UNIQUE)
        cursor.execute(f"""
            CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT NOT NULL,
                matricula TEXT NOT NULL,
                nota REAL NOT NULL,
                FOREIGN KEY (matricula) REFERENCES alunos(matricula) ON DELETE CASCADE
            )
        """)

        conn.commit()
        print("Tabelas criadas com sucesso!")

    except Exception as e:
        print(f"Erro ao criar tabelas: {e}")
    finally:
        conn.close()


# Inserir aluno sem duplicar
def inserir_aluno(nome, matricula):
    try:
        conn = conectar()
        cursor = conn.cursor()

        cursor.execute("""
            INSERT OR IGNORE INTO alunos (matricula, nome)
            VALUES (?, ?)
        """, (matricula, nome))

        conn.commit()
        print(f"Aluno {nome} inserido (ou já existia).")

    except Exception as e:
        print(f"Erro ao inserir aluno: {e}")
    finally:
        conn.close()


# Inserir nota
def inserir_nota(nome, matricula, nota):
    try:
        conn = conectar()
        cursor = conn.cursor()

        cursor.execute(f"""
            INSERT INTO {TABLE_NAME} (nome, matricula, nota)
            VALUES (?, ?, ?)
        """, (nome, matricula, nota))

        conn.commit()
        print(f"Nota de {nome} inserida com sucesso!")

    except sqlite3.IntegrityError as e:
        print(f"Erro de integridade: {e}")
    except Exception as e:
        print(f"Erro ao inserir nota: {e}")
    finally:
        conn.close()


# Listar notas
def listar_notas():
    try:
        conn = conectar()
        cursor = conn.cursor()

        cursor.execute(f"SELECT * FROM {TABLE_NAME}")
        rows = cursor.fetchall()
        return rows

    except Exception as e:
        print(f"Erro ao listar notas: {e}")
        return []

    finally:
        conn.close()


# Inserir notas em massa
def inserir_notas_em_massa(registros):
    try:
        conn = conectar()
        cursor = conn.cursor()

        cursor.executemany(f"""
            INSERT INTO {TABLE_NAME} (nome, matricula, nota)
            VALUES (?, ?, ?)
        """, registros)

        conn.commit()
        print("Notas inseridas em massa com sucesso!")

    except Exception as e:
        print(f"Erro ao inserir notas em massa: {e}")

    finally:
        conn.close()


# Gerar registros iniciais SOMENTE SE NÃO EXISTIREM ALUNOS
def gerar_registros_iniciais():
    conn = conectar()
    cursor = conn.cursor()

    cursor.execute("SELECT COUNT(*) FROM alunos")
    qtd = cursor.fetchone()[0]

    if qtd > 0:
        print("Registros iniciais já existem, ignorando criação.")
        conn.close()
        return

    conn.close()

    alunos_iniciais = [
        ("Andressa da Silva", "100000000000"),
        ("Bruno", "100000000001"),
        ("Carlos", "100000000002"),
        ("Daniela", "100000000003"),
        ("Eduardo Cordeiro", "100000000004"),
        ("Fernanda", "100000000005"),
        ("Augusto", "100000000006"),
        ("José Pedro da Galera", "100000000007"),
        ("Gabriel", "100000000008"),
        ("Geovana", "100000000009"),
        ("Cazuza", "100000000010"),
        ("Ticolé da Galera", "100000000011"),
        ("Tienam", "100000000012"),
        ("Luan", "100000000013"),
        ("Rômulo", "100000000014")
    ]

    for nome, matricula in alunos_iniciais:
        inserir_aluno(nome, matricula)

    registros = []
    for nome, matricula in alunos_iniciais:
        for _ in range(3):
            nota = round(random.uniform(0, 10), 1)
            registros.append((nome, matricula, nota))

    inserir_notas_em_massa(registros)


# Atualizar nota
def atualizar_nota(id, nova_nota):
    try:
        conn = conectar()
        cursor = conn.cursor()

        cursor.execute(f"""
            UPDATE {TABLE_NAME}
            SET nota = ?
            WHERE id = ?
        """, (nova_nota, id))

        conn.commit()

        if cursor.rowcount == 0:
            print("ID não encontrado.")
        else:
            print(f"Nota do aluno com ID {id} atualizada para {nova_nota}.")

    except Exception as e:
        print(f"Erro ao atualizar nota: {e}")
    finally:
        conn.close()


# Deletar nota
def deletar_nota(id):
    try:
        conn = conectar()
        cursor = conn.cursor()

        cursor.execute(f"DELETE FROM {TABLE_NAME} WHERE id = ?", (id,))
        conn.commit()

        if cursor.rowcount == 0:
            print("ID não encontrado.")
        else:
            print(f"Registro com ID {id} deletado.")

    except Exception as e:
        print(f"Erro ao deletar nota: {e}")
    finally:
        conn.close()


# MENU
def menu():
    while True:
        print("\n--- MENU ---")
        print("1. Listar as notas")
        print("2. Inserir uma nova nota")
        print("3. Atualizar a nota")
        print("4. Deletar a nota")
        print("9. Sair")

        try:
            opcao = int(input("Escolha uma opção: "))

            if opcao == 1:
                notas = listar_notas()
                for nota in notas:
                    print(nota)

            elif opcao == 2:
                nome = input("Nome do aluno: ")
                matricula = input("Matrícula: ")
                nota = float(input("Nota: "))
                inserir_nota(nome, matricula, nota)

            elif opcao == 3:
                id = int(input("ID da nota: "))
                nova_nota = float(input("Nova nota: "))
                atualizar_nota(id, nova_nota)

            elif opcao == 4:
                id = int(input("ID da nota a deletar: "))
                deletar_nota(id)

            elif opcao == 9:
                print("Encerrando...")
                break

            else:
                print("Opção inválida.")

        except Exception as e:
            print(f"Erro no menu: {e}")


# Executar
if __name__ == "__main__":
    criar_tabela()
    gerar_registros_iniciais()
    menu()

import sqlite3
import csv
import json
import random
import os

DB_NAME = "notas.db"
TABLE_NAME = "notas"

def conectar():
    return sqlite3.connect(DB_NAME)

def criar_tabela():
    try:
        conn = conectar()
        cursor = conn.cursor()

        # Criar tabela disciplinas
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS disciplinas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT NOT NULL
            )
        """)

        # Criar tabela alunos com curso_id e turma
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS alunos (
                matricula TEXT PRIMARY KEY,
                nome TEXT NOT NULL,
                email TEXT CHECK(email LIKE '%@%'),
                curso_id INTEGER,
                turma TEXT
            )
        """)

        # Criar tabela notas sem UNIQUE em matricula para permitir múltiplas notas por aluno
        cursor.execute(f"""
            CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT NOT NULL,
                matricula TEXT NOT NULL,
                nota REAL NOT NULL CHECK(nota BETWEEN 0 AND 10),
                disciplina_id INTEGER,
                FOREIGN KEY (matricula) REFERENCES alunos(matricula) ON DELETE CASCADE,
                FOREIGN KEY (disciplina_id) REFERENCES disciplinas(id) ON DELETE SET NULL
            )
        """)

        # Índice composto para curso_id e turma na tabela alunos
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_alunos_curso_turma ON alunos (curso_id, turma)
        """)

        conn.commit()
        print("Tabelas criadas com sucesso!")
    except Exception as e:
        print(f"Erro ao criar tabelas: {e}")
    finally:
        conn.close()

def inserir_aluno(nome, matricula, email, curso_id=None, turma=None):
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO alunos (nome, matricula, email, curso_id, turma)
            VALUES (?, ?, ?, ?, ?)
        """, (nome, matricula, email, curso_id, turma))
        conn.commit()
        print(f"Aluno {nome} inserido com sucesso!")
    except sqlite3.IntegrityError as e:
        print(f"Erro de integridade ao inserir aluno: {e}")
    except Exception as e:
        print(f"Erro ao inserir aluno: {e}")
    finally:
        conn.close()

def inserir_disciplina(nome):
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO disciplinas (nome)
            VALUES (?)
        """, (nome,))
        conn.commit()
        print(f"Disciplina {nome} inserida com sucesso!")
    except Exception as e:
        print(f"Erro ao inserir disciplina: {e}")
    finally:
        conn.close()

def inserir_nota(nome, matricula, nota, disciplina_id):
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute(f"""
            INSERT INTO {TABLE_NAME} (nome, matricula, nota, disciplina_id)
            VALUES (?, ?, ?, ?)
        """, (nome, matricula, nota, disciplina_id))
        conn.commit()
        print(f"Nota de {nome} inserida com sucesso!")
    except sqlite3.IntegrityError as e:
        print(f"Erro de integridade ao inserir nota: {e}")
    except Exception as e:
        print(f"Erro ao inserir nota: {e}")
    finally:
        conn.close()

def gerar_registros_iniciais():
    alunos_iniciais = [
        ("Andressa da Silva", "100000000000", "andressa@exemplo.com", 1, "A"),
        ("Bruno", "100000000001", "bruno@exemplo.com", 1, "A"),
        ("Carlos", "100000000002", "carlos@exemplo.com", 2, "B"),
        ("Daniela", "100000000003", "daniela@exemplo.com", 2, "B"),
        ("Eduardo Cordeiro", "100000000004", "eduardo@exemplo.com", 3, "C")
    ]

    disciplinas_iniciais = [
        "Matemática",
        "Física",
        "Química",
        "Biologia"
    ]

    for nome, matricula, email, curso_id, turma in alunos_iniciais:
        inserir_aluno(nome, matricula, email, curso_id, turma)

    for nome in disciplinas_iniciais:
        inserir_disciplina(nome)

    registros = []
    for nome, matricula, _, _, _ in alunos_iniciais:
        for _ in range(3):  # 3 notas por aluno
            nota = round(random.uniform(0, 10), 1)
            disciplina_id = random.randint(1, 4)
            registros.append((nome, matricula, nota, disciplina_id))

    for registro in registros:
        inserir_nota(*registro)

def top_3_alunos():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT
                a.nome,
                AVG(n.nota) AS media_geral
            FROM
                alunos a
            JOIN
                notas n ON a.matricula = n.matricula
            GROUP BY
                a.matricula
            ORDER BY
                media_geral DESC
            LIMIT 3
        """)
        rows = cursor.fetchall()
        for row in rows:
            print(f"Aluno: {row[0]}, Média: {row[1]:.2f}")
    except Exception as e:
        print(f"Erro ao gerar relatório de top 3 alunos: {e}")
    finally:
        conn.close()

def media_por_curso_turma():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT
                a.curso_id,
                a.turma,
                AVG(n.nota) AS media_nota
            FROM
                alunos a
            JOIN
                notas n ON a.matricula = n.matricula
            GROUP BY
                a.curso_id, a.turma
        """)
        rows = cursor.fetchall()
        for row in rows:
            print(f"Curso: {row[0]}, Turma: {row[1]}, Média: {row[2]:.2f}")
    except Exception as e:
        print(f"Erro ao gerar relatório de média por curso e turma: {e}")
    finally:
        conn.close()

def listar_alunos_sem_notas():
    try:
        conn = conectar()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT
                a.nome
            FROM
                alunos a
            LEFT JOIN
                notas n ON a.matricula = n.matricula
            WHERE
                n.id IS NULL
        """)
        rows = cursor.fetchall()
        for row in rows:
            print(f"Aluno sem nota: {row[0]}")
    except Exception as e:
        print(f"Erro ao listar alunos sem notas: {e}")
    finally:
        conn.close()

def exportar_csv():
    try:
        conn = conectar()
        cursor = conn.cursor()

        with open("alunos.csv", mode="w", newline="") as file:
            writer = csv.writer(file)
            cursor.execute("SELECT * FROM alunos")
            writer.writerow([description[0] for description in cursor.description])
            writer.writerows(cursor.fetchall())

        with open("disciplinas.csv", mode="w", newline="") as file:
            writer = csv.writer(file)
            cursor.execute("SELECT * FROM disciplinas")
            writer.writerow([description[0] for description in cursor.description])
            writer.writerows(cursor.fetchall())

        with open("notas.csv", mode="w", newline="") as file:
            writer = csv.writer(file)
            cursor.execute("SELECT * FROM notas")
            writer.writerow([description[0] for description in cursor.description])
            writer.writerows(cursor.fetchall())

        print("Dados exportados para CSV com sucesso!")
    except Exception as e:
        print(f"Erro ao exportar para CSV: {e}")
    finally:
        conn.close()

def exportar_json():
    try:
        conn = conectar()
        cursor = conn.cursor()

        cursor.execute("SELECT * FROM v_media_por_disciplina")
        rows = cursor.fetchall()
        colunas = [desc[0] for desc in cursor.description]

        with open("v_media_por_disciplina.json", "w") as f:
            json.dump([dict(zip(colunas, row)) for row in rows], f, indent=4)

        print("View exportada para JSON com sucesso!")
    except Exception as e:
        print(f"Erro ao exportar JSON: {e}")
    finally:
        conn.close()

if __name__ == "__main__":
    # Apagar banco antigo para evitar conflitos
    if os.path.exists(DB_NAME):
        os.remove(DB_NAME)

    criar_tabela()
    gerar_registros_iniciais()

    print("\n--- Top 3 Alunos ---")
    top_3_alunos()

    print("\n--- Média por Curso e Turma ---")
    media_por_curso_turma()

    print("\n--- Alunos sem notas ---")
    listar_alunos_sem_notas()